NAME: Jack Mandell
CONTACT INFO: jmandel5@u.rochester.edu
PROJECT CONTENTS: DrawMap.java, Edge.java, Graph.java, Vertex.java
PROJECT DESCRIPTION:
In this project, we had to implement a graph class that could handle intersections and roads of various maps. For each of these maps, we had to implement the minimum spanning tree algorithm and shortest path algorthm and be able to display and print these results to the drawing window and command line. 
HOW MY CODE WORKS/RUNTIME ANALYSIS:
Over the course of this project, I have had to change how my Graph, Edge, and Vertex classes were set up. Initially, I had used an adjacency List to store edges, but after I tried drawing the map with the monroe.txt, I was getting an out of memory error. So, I scrapped that idea and used the current implementation I have now. To make the graph data structure, I used a hashmap of String keys and Vertex values in the Graph class. The Strings are the names of the verticies (given by the file). To take into account the edges, the Vertex class has a Hashtable of Strings that represent the names of the neighboring verticies. I used Strings instead of Vertex objects for the neighbors because it cut down on storage and simplified my code. The Graph class also contains other instance variable such as MIN_LAT, MAX_LAT, etc. that are for the drawing part. The other varibales are used for specific methods in the Graph class only and will be discussed later.

To draw the plots, I used the JPanel class and paintComponent() method. I was new to the Java graphics library so my implementation may have not been the greatest, but it got the job done in a short amount of time. To draw the map, I created a drawMap method. This method iterates though the hashMap of verticies and through the HashTable of neighbors and draws a line between each vetex and its neighbors. I calculated the distance between verticies using the haversine function (https://gist.github.com/vananth22/888ed9a22105670e7a4092bdcf0d72e4) from online and scaled the distance relative to the window size. Theoretically, this would take O(V*E) runtime, but since most intersections are not connected to a lot of other intersections, the amount of time spent in the inner part of the loop is much less than E. If the graph was more dense, my implementation may pose an issue, since there is a lot of redundant drawing. To draw the shortest path, I made a recursive method called drawPath, which draws a line between a vertex and its parent reference, governed by the shortest path algorithm. This method repeats until the parent reference is null.

For the shortest path algorithm, I used a Priority queue of verticies. The code runs until the queue is empty. Each pass (max O(V) times), the vertex with the minimum distance from the source is removed (which takes at worst O(log V)) and it is set as known. After, if the neighbor is not known, all neighbors of that vertex are checked for their distance from the source (at worst O(E) times). If the new distance from the source is smaller than the current distance, and it is not currently contained in the queue (takes log(V) runtime to check), the it is added to the queue. The total runtime based on these partial runtimes of the method can then be summarized as O( E log V + V log V) = O ( (E + V) log V). At first, I was not checking if the queue already contained the given vertex, so I was adding the Vertex every iteration. This was fine for the ur map, but then for monroe, I was getting out of memory errors. In practice, this algorithm runs in <1 second for ur.txt, ~2 seconds for monroe.txt, and ~7 seconds for nys.txt. Based on these results, it is definitely linear-logarithmic runtime. 

For the MST algorithm method, I used a prioirty queue of edges, and the method returns an ArrayList of edges. Each iteration (max O(E) time), the edge with the smallest weight is removed ( take O(log E) ). If the addition of this weight does not create a cycle, it is added to the ArrayList of edges to be returned. The algorithm uses an array implementation of union find to determine if two verticies are in a cycle. The find method takes O(V) runtime and union is O(1). This implies that the runtime of this method is O( E log (E+2V) ). 

NOTE: when the MST is run for nys, it is hard to see the difference between the original tree and the MST, however, there is a difference (there are pockets of orange sticking out).
